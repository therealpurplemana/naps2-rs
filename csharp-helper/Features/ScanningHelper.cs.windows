using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;
using System.Linq;
using System.Reflection;
using NAPS2.Images;
using NAPS2.Scan;
using NAPS2.Images.Gdi;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

namespace NAPS2Helper.Features
{
    public static class ScanningHelper
    {
        private static readonly string LogPath = Path.Combine(
            Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) ?? "", 
            "naps2_helper.log");
            
        static ScanningHelper()
        {
            // Ensure log directory exists and write a startup entry
            try
            {
                var logDir = Path.GetDirectoryName(LogPath);
                if (!string.IsNullOrEmpty(logDir) && !Directory.Exists(logDir))
                {
                    Directory.CreateDirectory(logDir);
                }
                File.AppendAllText(LogPath, $"[{DateTime.Now}] Application started\n");
            }
            catch
            {
                // Ignore startup logging errors
            }
        }
            
        private static ILoggerFactory CreateLoggerFactory()
        {
            return LoggerFactory.Create(builder => 
                builder.AddSimpleFileLogger(LogPath).SetMinimumLevel(LogLevel.Debug));
        }

        public static async Task<string> ListDevices(string driverName)
        {
            try
            {
                using var scanningContext = new ScanningContext(new GdiImageContext());
                
                Driver driver = Driver.Default;
                if (!string.IsNullOrEmpty(driverName) && Enum.TryParse<Driver>(driverName, true, out var parsedDriver))
                {
                    driver = parsedDriver;
                }
                
                var options = new ScanOptions { Driver = driver };
                
                // Configure driver-specific options
                if (driver == Driver.Twain)
                {
                    if (Environment.Is64BitProcess)
                    {
                        // We're running as 64-bit, but need 32-bit access to TWAIN
                        File.AppendAllText(LogPath, $"[{DateTime.Now}] Avoiding TWAIN in 64-bit mode\n");
                        return "[]"; // Return empty device list as TWAIN needs extra setup
                    }
                    
                    options.TwainOptions = new TwainOptions
                    {
                        Dsm = TwainDsm.New, // Use basic DSM for 32-bit
                        TransferMode = TwainTransferMode.Memory,
                        IncludeWiaDevices = true
                    };
                }
                
                var controller = new ScanController(scanningContext);
                var devices = await controller.GetDeviceList(options);
                
                var deviceList = new List<object>();
                foreach (var device in devices)
                {
                    deviceList.Add(new
                    {
                        Id = device.ID,
                        Name = device.Name,
                        Driver = device.Driver.ToString()
                    });
                }
                
                return JsonSerializer.Serialize(deviceList, new JsonSerializerOptions
                {
                    WriteIndented = true
                });
            }
            catch (Exception ex)
            {
                // Log error to file without affecting stdout
                File.AppendAllText(LogPath, $"[ERROR] {DateTime.Now}: {ex.Message}\n{ex.StackTrace}\n\n");
                
                // Return empty array to avoid JSON parsing errors
                return "[]";
            }
        }
        
        public static async Task<string> ScanToImages(string deviceId, string driverName, int dpi, string paperSource)
        {
            try
            {
                using var scanningContext = new ScanningContext(new GdiImageContext());
                
                // Find the device by ID
                Driver driver = Driver.Default;
                if (!string.IsNullOrEmpty(driverName) && Enum.TryParse<Driver>(driverName, true, out var parsedDriver))
                {
                    driver = parsedDriver;
                }
                
                var controller = new ScanController(scanningContext);
                
                var options = new ScanOptions 
                { 
                    Driver = driver,
                    Dpi = dpi
                };
                
                // Configure driver-specific options
                if (driver == Driver.Twain)
                {
                    if (Environment.Is64BitProcess)
                    {
                        // TWAIN scanning is complex in 64-bit mode
                        throw new NotSupportedException("TWAIN scanning from 64-bit mode is not supported. Please use WIA driver instead.");
                    }
                    
                    options.TwainOptions = new TwainOptions
                    {
                        Dsm = TwainDsm.New, // Use basic DSM for 32-bit
                        TransferMode = TwainTransferMode.Memory,
                        IncludeWiaDevices = true
                    };
                }
                
                // Set paper source if provided
                if (!string.IsNullOrEmpty(paperSource) && Enum.TryParse<PaperSource>(paperSource, true, out var parsedSource))
                {
                    options.PaperSource = parsedSource;
                }
                
                // Find the device by ID
                var devices = await controller.GetDeviceList(options);
                var device = devices.Find(d => d.ID == deviceId);
                
                if (device == null)
                {
                    throw new Exception($"Device with ID {deviceId} not found");
                }
                
                options.Device = device;
                
                // Create a temp directory for images
                var tempDir = Path.GetTempPath();
                var sessionDir = Path.Combine(tempDir, $"naps2_scan_{Guid.NewGuid()}");
                Directory.CreateDirectory(sessionDir);
                
                // Scan and save images
                int i = 1;
                var imagePaths = new List<string>();
                
                await foreach (var image in controller.Scan(options))
                {
                    var imagePath = Path.Combine(sessionDir, $"page{i++}.jpg");
                    var renderableImage = (IRenderableImage)image;
                    ImageExtensions.Save(renderableImage, imagePath, ImageFileFormat.Jpeg);
                    imagePaths.Add(imagePath);
                }
                
                return JsonSerializer.Serialize(new
                {
                    ImagePaths = imagePaths,
                    TempDirectory = sessionDir
                }, new JsonSerializerOptions
                {
                    WriteIndented = true
                });
            }
            catch (Exception ex)
            {
                // Log error to file without affecting stdout
                File.AppendAllText(LogPath, $"[ERROR] {DateTime.Now}: {ex.Message}\n{ex.StackTrace}\n\n");
                
                // Return error JSON
                return JsonSerializer.Serialize(new
                {
                    Error = ex.Message,
                    StackTrace = ex.StackTrace
                }, new JsonSerializerOptions
                {
                    WriteIndented = true
                });
            }
        }

        public static string SaveAsJpeg(List<string> imagePaths, string outputDir)
        {
            try
            {
                // Ensure output directory exists
                if (!Directory.Exists(outputDir))
                {
                    Directory.CreateDirectory(outputDir);
                }
                
                // Initialize the scanning context
                using var scanningContext = new ScanningContext(new GdiImageContext());
                var imageContext = scanningContext.ImageContext;
                
                // Output file paths
                var outputFiles = new List<string>();
                int index = 1;
                
                // Process each input image
                foreach (var imagePath in imagePaths)
                {
                    if (File.Exists(imagePath))
                    {
                        try
                        {
                            // Load the image
                            var image = imageContext.Load(imagePath);
                            
                            // Save as JPEG with a numbered filename
                            var outputPath = Path.Combine(outputDir, $"image_{index:D3}.jpg");
                            var renderableImage = (IRenderableImage)image;
                            ImageExtensions.Save(renderableImage, outputPath, ImageFileFormat.Jpeg);
                            outputFiles.Add(outputPath);
                            
                            // Clean up
                            image.Dispose();
                            index++;
                        }
                        catch (Exception ex)
                        {
                            File.AppendAllText(LogPath, $"[ERROR] {DateTime.Now}: Error processing image {imagePath}: {ex.Message}\n");
                        }
                    }
                }
                
                // Return success result with output file paths
                return JsonSerializer.Serialize(new
                {
                    Success = true,
                    Directory = outputDir,
                    Files = outputFiles,
                    Count = outputFiles.Count
                }, new JsonSerializerOptions { WriteIndented = true });
            }
            catch (Exception ex)
            {
                // Log error to file without affecting stdout
                File.AppendAllText(LogPath, $"[ERROR] {DateTime.Now}: {ex.Message}\n{ex.StackTrace}\n\n");
                
                // Return error result
                return JsonSerializer.Serialize(new
                {
                    Success = false,
                    Error = ex.Message,
                    StackTrace = ex.StackTrace
                }, new JsonSerializerOptions { WriteIndented = true });
            }
        }
    }
    
    // Simplified file logger implementation
    public static class FileLoggerExtensions
    {
        public static ILoggingBuilder AddSimpleFileLogger(this ILoggingBuilder builder, string filePath)
        {
            builder.Services.AddSingleton<ILoggerProvider>(new SimpleFileLoggerProvider(filePath));
            return builder;
        }
    }
    
    public class SimpleFileLoggerProvider : ILoggerProvider
    {
        private readonly string _filePath;
        
        public SimpleFileLoggerProvider(string filePath)
        {
            _filePath = filePath;
        }
        
        public ILogger CreateLogger(string categoryName)
        {
            return new SimpleFileLogger(_filePath);
        }
        
        public void Dispose() { }
    }
    
    public class SimpleFileLogger : ILogger
    {
        private readonly string _filePath;
        
        public SimpleFileLogger(string filePath)
        {
            _filePath = filePath;
        }
        
        public IDisposable? BeginScope<TState>(TState state) where TState : notnull
        {
            return null;
        }
        
        public bool IsEnabled(LogLevel logLevel) => true;
        
        public void Log<TState>(
            LogLevel logLevel, 
            EventId eventId, 
            TState state, 
            Exception? exception, 
            Func<TState, Exception?, string> formatter)
        {
            try
            {
                var message = formatter(state, exception);
                var line = $"[{DateTime.Now}][{logLevel}] {message}";
                if (exception != null)
                {
                    line += $"\n{exception}";
                }
                File.AppendAllText(_filePath, line + "\n");
            }
            catch
            {
                // Suppress logging errors
            }
        }
    }
}